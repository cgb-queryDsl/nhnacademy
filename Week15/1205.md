# 1205 정리

### Spring Security 1일차

<br/>

**이전까지 로그인 처리**
```java
@Controller
@RequestMapping("/login")
public class LoginController {

    private final String SESSION = "session";
    private final UserService userService;

    public LoginController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public String login(@RequestParam("id") String loginId,
                        @RequestParam("pw") String loginPw, HttpSession session) {

        Optional<User> optional = userService.getLoginUser(loginId);
        try {
            if (optional.isPresent() && optional.get().getPassword().equals(loginPw)) {
                session.setAttribute(SESSION, optional.get().getId() + "-" + optional.get().getNickname() + "-on");

                return "redirect:/community?page=1";
            }
        } catch (NoSuchElementException e) {
            return "index/index";
        }

        return "index/index";
    }
}
```
- DB혹은 메모리 저장소에 저장된 ID & Password를 비교하고 일치하는 경우에 세션을 등록하는 식으로 구현
- **BUT** 이 방법에는 문제가 있음
    1. DB에 `password`를 그냥 plain text로 저장하는 방법은 <span style="color:red">절대 해선 안되는 짓</span>

<br/>

**단방향 해시 함수의 다이제스트**
- `해시`를 사용
- 해시함수
    - 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수
    <img width="320" alt="image" src="https://user-images.githubusercontent.com/87689191/205930764-e8387402-5f5c-4769-9e41-8ffddaed4869.png">
    - `John Smith`을 가지고 해시값은 알 수 있음
    - 해시값을 가지고 `John Smith`를 알 방법은 없음
- 해시의 특성
    - 해시는 고정 길이 == 원문이 손실
    - 원문과 해시 값 사이에 선형적인 관계가 없음
- 해시 알고리즘 종류
    - MD5 : 128비트 길이
    - SHA-1 : 160비트 길이
    - SHA-256 : 256비트 길이


<br/>

**단방향 해시 함수의 문제점**
- 인식 가능성
    - 동일한 메시지는 동일한 해시값을 가진다.
- 속도
    - 해시 함수는 빠른 데이터 검색을 위한 목적으로 설계된 알고리즘
    - 속도가 빠르기에 임의의 문자열에 대해 해킹할 해시값을 비교가 가능
    - 하나의 사전을 만들어 모든 문자열 조합에 대해 해시값을 찾는 것이 가능하단 이이기

<Br/>

**Salt**
- 단방향 해시 함수를 해결할 방법
- 소금을 뿌리듯이 바이트 단위의 임의의 문자열을 추가해서 N번 반복을 함

<br/>

**예시**
- 단방향 해시 함수
- 1024번 반복
```java
public class PasswordUtils {
    private static final int DEFAULT_ITERATIONS = 1024;

    private PasswordUtils() {
        throw new IllegalStateException("Utility class");
    }

    public static String simple(String rawPassword) {
        byte[] digest = null;
        try {
            digest = sha256WithoutSaltAndIterations(rawPassword);
        } catch (NoSuchAlgorithmException ex) {
            log.error("", ex);
        }

        return bytesToHex(digest);
    }

    public static String encode(String rawPassword, byte[] salt) {
        return encode(rawPassword, salt, DEFAULT_ITERATIONS);
    }

    public static String encode(String rawPassword, byte[] salt, int iterations) {
        byte[] digest = null;
        try {
            digest = sha256(rawPassword, salt, iterations);
        } catch (NoSuchAlgorithmException ex) {
            log.error("", ex);
        }

        return bytesToHex(digest);
    }

    private static byte[] sha256(String rawPassword, byte[] salt, int iterations) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.reset();
        digest.update(salt);

        byte[] input = digest.digest(rawPassword.getBytes(StandardCharsets.UTF_8));
        for (int i = 0; i < iterations; i++) {
            digest.reset();
            input = digest.digest(input);
        }

        return input;
    }

    private static byte[] sha256WithoutSaltAndIterations(String rawPassword) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.reset();
        return digest.digest(rawPassword.getBytes(StandardCharsets.UTF_8));
    }

    public static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b: bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

}
```
- 테스트 
```java
@Test
void test() {
    String password = "12345";

    List<String> hashes = new ArrayList<>();

    for (int i = 0; i < 10; i++) {
        hashes.add(PasswordUtils.simple(password));
    }

    for (int i = 0; i < 10; i++) {
        assertThat(hashes.get(i)).isEqualTo("5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5");
    }

    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[8];

    hashes.clear();

    for (int i = 0; i < 10; i++) {
        random.nextBytes(salt);
        String digest = PasswordUtils.encode(password, salt);

        System.out.println("salt=" + PasswordUtils.bytesToHex(salt) + ", digest=" + digest);
        hashes.add(digest);
    }

    Set<String> set = new HashSet<>(hashes);
    assertThat(set).hasSize(10);
}
```
- "12345"에 대해서는 동일한 해시 값이 나오는 것을 보여줌
- `salt`를 추가하면 각기 다른 해시 값이 나오는 것을 보여줌
```java
// 출력
salt=8e86653c7a828f55, digest=7a852c92e3cea15fa22ef02d515659a08b77c4b0b05989cb7aec5150a7447a53
salt=fc110fe4fa87f483, digest=00f17ffe36048ea97b73214e871c1c30a57306f97111c77a5c65f09bae1ac709
salt=b3e636bbe3cd7ac9, digest=c822badcb082caad64ada503f69e60473c7c4fe638ce3efc45460ba8fecdadc2
salt=3cd6c044b89e6d15, digest=6cc6750b24a4be53eb06e6758d02ebf5c38f7e84e929809ac004d73f664afb66
salt=344c29bbe30ef71c, digest=d5933830fc1bfa1ef9e7ba3d5869cfe9eb6649887e86ea2b2ea449eacc5ab84a
salt=3470901922dabf09, digest=f625aed9b263c5bacee195f7f876740978a5aaa283f785d4d19cf23180da0a91
salt=209c69c6f8c9f572, digest=f07a3606cfada93beaf03ffff7676a91a5a9d772f721e5d9027b53898578e5f4
salt=dfff05be66b77232, digest=2a628d724c5516a3793473e1e6e38651f0ca0ab961d0291a23aef9fe6614d7a3
salt=119413358b0d27b4, digest=3b94d02c1591fffd5ced7172549cfc088ad7b21ee47d314eb1f3a002072eb164
salt=0676869ba1ab7855, digest=0a1f239daa08c1e50cfd442c7155e0df1ef4c1e0f6e5deaeeef56bd66d07ee18
```

<Br/>

**쿠키와 세션**
- 쿠키
    - 브라우저에 저장
    - 개인정보를 쿠키에 저장하는 것은 <span style="color:red">금물</span>
- 세션
    - 서버에 저장

<br/>

세션은 서버에 저장되기 때문에 브라우저를 껏다가 다시 키면 세션을 찾을 수가 없다.   
--> 최소한 쿠키에 세션 아이디를 남겨놓아야 세션값을 찾을 수 있다. (서버가 2개 이상이면 반드시 챙겨야할 부분)  
--> `Redis`를 주로 사용

---

### Spring Security
