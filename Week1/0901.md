# 0901 정리

### 문제 1. BinarySearch를 구현하기.
---

### Code

<details>
    <summary>BinarySearch</summary>

```java
import java.util.Arrays;

public class BinarySearch {

    int array [];

    public BinarySearch(int n) {
        this.array = new int [n];
    }

    public void addNumber(int index, int n) {
        this.array[index] = n;
    }

    public void sort() {
        Arrays.sort(array);
    }

    public int runBinarySearch(int key, int low, int high) {
        int mid;

        while(low <= high) {
            mid = (low + high) / 2;

            if(key == this.array[mid]) {
                return mid;
            } else if(key < this.array[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return -1;
    }

    public int[] getArray() {
        return array;
    }

    public void setArray(int[] array) {
        this.array = array;
    }

    @Override
    public String toString() {
        return Arrays.toString(array);
    }
}
```

</details>

---
### 문제 1.1 Binary 난수 n개를 생성하고 검색 시간 체크하기.
---

### Test Code
<details>
    <summary>BinarySearchTest</summary>

```java
import java.util.Arrays;
import java.util.Random;

class BinarySearchTest {

    public static void main(String[] args) {
        BinarySearch binarySearch = new BinarySearch(10000000);

        int findNumber1 = 0;
        int findNumber2 = 0;

        // 난수 생성
        Random random = new Random();
        for(int i = 0; i < binarySearch.array.length; i++) {
            int randomNum = random.nextInt();

            binarySearch.addNumber(i, randomNum);

            // 임의의 index 값을 설정해서 찾을 번호 저장
            if (i == 3940)
                findNumber1 = randomNum;
            if (i == 7981)
                findNumber2 = randomNum;
        }

        // 정렬
        binarySearch.sort();

        int temp [] = binarySearch.getArray();

        long beforeTime1 = System.currentTimeMillis();
        System.out.println(binarySearch.runBinarySearch(findNumber1, 0, binarySearch.array.length - 1));
        long afterTime1 = System.currentTimeMillis();
        long secDiffTime1 = (afterTime1 - beforeTime1) / 1000;
        System.out.println(secDiffTime1);

        long beforeTime2 = System.currentTimeMillis();
        System.out.println(binarySearch.runBinarySearch(findNumber2, 0, binarySearch.array.length - 1));
        long afterTime2 = System.currentTimeMillis();
        long secDiffTime2 = (afterTime2 - beforeTime2) / 1000;
        System.out.println(secDiffTime2);

        System.out.println(Arrays.binarySearch(temp, findNumber1));
        System.out.println(Arrays.binarySearch(temp, findNumber2));
    }

}
```

</details>

---
### 문제 1 배운것들
- `BinarySearch`는 정렬이 되어 있어야 함.
- 난수를 많이 생성한다고 해서 검색 시간이 크게 늘어나지 않음. (난수 생성하는 시간이 더 길어질 뿐)
- `System.currentTimeMillis()`를 사용해서 ms를 체크했지만 최근에는 IoT같은 분야에서 `System.nanoTime()` nano단위로 시간을 체크한다고 함.

<br/>

### 문제 1 후기
- m1칩 빠르다.. ✌️
- 이진탐색은 첨 들어본 내용이 아니여서 어렵지 않았음.

<br/>

**이해 점수** : 4.8 / 5

---
### 문제 2. 배열에 사용할 다양한 도구를 만들기. (MyArray)
---
### 문제 2.1 배열이 정렬되어 있는지 isSorted() 구현

### Code

<details>
    <summary>isSorted()</summary>

```java
public class MyArray {

    public boolean isSorted(int arr[]) {
        int previous = arr[0];

        for (int i = 1; i < arr.length; i++) {
            if (previous > arr[i]) {
                return false;
            }
            previous = arr[i];
        }

        return true;
    }
}
```

</details>

---
### 문제 2.2 배열에서 최솟값 / 최댓값 찾기
### Code
<details>
    <summary>getMaxValue,() getMinValue()</summary>

```java
public int getMaxValue(int arr[]) {
    int max = arr[0];

    for(int i = 1; i < arr.length; i++) {
        if (max < arr[i]){
            max = arr[i];
        }
    }

    return max;
}

public int getMinValue(int arr[]) {
    int min = arr[0];

    for(int i = 1; i < arr.length; i++) {
        if (min > arr[i]){
            min = arr[i];
        }
    }

    return min;
}
```

</details>

--- 
### 문제 2.3 배열의 평균
### Code

<details>
    <summary>getAverage()</summary>

```java
public double getAverage(int arr[]) {
    int sum = 0;

    for(int i : arr) {
        sum += i;
    }

    return (double) sum / arr.length;
}
```

</details>

---
### 문제 2.4 배열에서 중복값 제거
### Code

<details>
    <summary>deleteDuplicate()</summary>

```java
public String deleteDuplicate(int arr[]) {
    int temp [] = Arrays.stream(arr).distinct().toArray();

    return Arrays.toString(temp);
}
```

</details>

---
### 문제 2.5 배열을 새롭게 생성하지 않고 뒤집기
### Code

<details>
    <summary>reverse()</summary>

```java
public String reverse(int arr[]) {
    ArrayList<Integer> list = new ArrayList<>();

    for (int i = 0; i < arr.length; i++) {
        list.add(arr[i]);
    }

    Collections.reverse(list);

    return list.toString();
}
```

</details>

---
### 문재 2.6 두 개의 배열을 연결
### Code

<details>
    <summary>extend()</summary>

```java
public String extend(int arr1[], int arr2[]) {
    int temp [] = new int[arr1.length + arr2.length];

    for (int i = 0; i < arr1.length; i++) {
        temp[i] = arr1[i];
    }

    for(int j = arr1.length, i = 0; j < temp.length; j++, i++ ) {
        temp[j] = arr2[i];
    }

    return Arrays.toString(temp);
}
```

</details>

---
### 문제 2.7 문자열에서 알파벳 개수 카운트
### Code

<details>
    <summary>countAlpha()</summary>

```java
public void countAlpha(String str) {

    int count [] = new int[26];

    for (int i = 0; i < str.length(); i++) {
        char ch = str.toUpperCase().charAt(i);
        if(Character.isLetter(ch))
            count[ch - 'A']++;
    }
    for (int i = 0; i < 26; i++) {
        System.out.println((char) (65 + i) + " : " + count[i]);
    }
}
```

</details>

--- 
### 문제 2.8 두 개의 double 배열
<img width="169" alt="스크린샷 2022-09-01 오후 5 35 25" src="https://user-images.githubusercontent.com/87689191/187870455-0fb9e121-66cc-4604-bc9d-881196ce1aaf.png">

### Code


<details>
    <summary>getDoubleArray()</summary>

```java
public double getDoubleArray(double arr1[], double arr2[]) throws InvalidParameterException {
    double sum = 0;

    if (arr1.length != arr2.length)
        throw new InvalidParameterException("not match!!");

    for(int i = 0; i < arr1.length; i++) {
        sum += arr1[i] * arr2[i];
    }

    return sum;
}
```

</details>

---
### 문제 2.9 두 개의 double 배열
<img width="246" alt="스크린샷 2022-09-01 오후 5 43 55" src="https://user-images.githubusercontent.com/87689191/187872060-b702fe4e-f474-4112-bb38-e464bb7445ec.png">

### Code

<details>
    <summary>matrix1D()</summary>

```java
public String matrix1D(int arr1[], int arr2 []) {
    int temp [] = new int [1];
    int sum = 0;

    for(int i = 0; i < arr1.length; i++) {
        sum += arr1[i] * arr2[i];
    }
    temp[0] = sum;

    return Arrays.toString(temp);
}
```

</details>

---
### 문제 2.10 두 개의 행렬의 곱셈
<img width="127" alt="그림1" src="https://user-images.githubusercontent.com/87689191/187873252-fb57887b-abeb-4c81-9110-d7597cd8c010.png">

### Code

<details>
    <summary>matrixMultiply()</summary>

```java
public String matrixMultiply(int arr1[][], int arr2[][]) throws InvalidParameterException{
    int temp [][] = new int[arr1.length][arr2[0].length];

    if (arr1[0].length != arr2.length) {
        throw new InvalidParameterException("not match");
    }

    for(int i = 0; i < temp.length; i++){
        for(int j = 0; j < temp[i].length; j++){
            for(int k = 0; k < arr1[0].length; k++){
                temp[i][j] += arr1[i][k] * arr2[k][j];
            }
        }
    }

    return Arrays.deepToString(temp);
}
```

</details>

---
### 전체 Code

<details>
<summary> MyArray </summary>

```java
import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class MyArray {

    /**
     * 배열이 정렬되어 있는지 확인
     */
    public boolean isSorted(int arr[]) {
        int previous = arr[0];

        for (int i = 1; i < arr.length; i++) {
            if (previous > arr[i]) {
                return false;
            }
            previous = arr[i];
        }

        return true;
    }

    /**
     * 배열에서 최댓값 출력
     */
    public int getMaxValue(int arr[]) {
        int max = arr[0];

        for(int i = 1; i < arr.length; i++) {
            if (max < arr[i]){
                max = arr[i];
            }
        }

        return max;
    }

    /**
     * 배열에서 최솟값 출력
     */
    public int getMinValue(int arr[]) {
        int min = arr[0];

        for(int i = 1; i < arr.length; i++) {
            if (min > arr[i]){
                min = arr[i];
            }
        }

        return min;
    }

    /**
     * 배열에서 평균값 출력
     */
    public double getAverage(int arr[]) {
        int sum = 0;

        for(int i : arr) {
            sum += i;
        }

        return (double) sum / arr.length;
    }

    /**
     * 배열에서 중복값 제거
     */
    public String deleteDuplicate(int arr[]) {
        int temp [] = Arrays.stream(arr).distinct().toArray();

        return Arrays.toString(temp);
    }

    /**
     * 배열 뒤집기
     */
    public String reverse(int arr[]) {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < arr.length; i++) {
            list.add(arr[i]);
        }

        Collections.reverse(list);

        return list.toString();
    }

    /**
     * 두 개의 배열 연결
     */
    public String extend(int arr1[], int arr2[]) {
        int temp [] = new int[arr1.length + arr2.length];

        for (int i = 0; i < arr1.length; i++) {
            temp[i] = arr1[i];
        }

        for(int j = arr1.length, i = 0; j < temp.length; j++, i++ ) {
            temp[j] = arr2[i];
        }

        return Arrays.toString(temp);
    }

    /**
     * 알파벳 수 카운트
     */
    public void countAlpha(String str) {

        int count [] = new int[26];

        for (int i = 0; i < str.length(); i++) {
            char ch = str.toUpperCase().charAt(i);
            if(Character.isLetter(ch))
                count[ch - 'A']++;
        }
        for (int i = 0; i < 26; i++) {
            System.out.println((char) (65 + i) + " : " + count[i]);
        }
    }

    /**
     * 두 개의 double 배열을 받아 시그마합
     */
    public double getDoubleArray(double arr1[], double arr2[]) throws InvalidParameterException {
        double sum = 0;

        if (arr1.length != arr2.length)
            throw new InvalidParameterException("not match!!");

        for(int i = 0; i < arr1.length; i++) {
            sum += arr1[i] * arr2[i];
        }

        return sum;
    }

    /**
     * 1차원 행렬 곱
     */
    public String matrix1D(int arr1[], int arr2 []) {
        int temp [] = new int [1];
        int sum = 0;

        for(int i = 0; i < arr1.length; i++) {
            sum += arr1[i] * arr2[i];
        }
        temp[0] = sum;

        return Arrays.toString(temp);
    }
    
    /**
     * n차원 행렬 곱
     */
    public String matrixMultiply(int arr1[][], int arr2[][]) throws InvalidParameterException{
        int temp [][] = new int[arr1.length][arr2[0].length];

        if (arr1[0].length != arr2.length) {
            throw new InvalidParameterException("not match");
        }

        for(int i = 0; i < temp.length; i++){
            for(int j = 0; j < temp[i].length; j++){
                for(int k = 0; k < arr1[0].length; k++){
                    temp[i][j] += arr1[i][k] * arr2[k][j];
                }
            }
        }

        return Arrays.deepToString(temp);
    }
}

```

</details>

<br/>

### Test Code

<details>
<summary> MyArrayTest</summary>

```java
import java.security.InvalidParameterException;

class MyArrayTest {

    public static void main(String[] args) throws InvalidParameterException {
        int temp [] = {1, 3, 4, 2, 6, 6, 8};
        int temp1 [] = {2, 3, 4, 5, 5, 5, 10};

        MyArray myArray = new MyArray();

        // isSorted()
        System.out.println(myArray.isSorted(temp));
        System.out.println(myArray.isSorted(temp1));

        // 최댓값 & 최솟값
        System.out.println(myArray.getMaxValue(temp));
        System.out.println(myArray.getMaxValue(temp1));
        System.out.println(myArray.getMinValue(temp));
        System.out.println(myArray.getMinValue(temp1));

        // 배열의 평균
        System.out.println(myArray.getAverage(temp));
        System.out.println(myArray.getAverage(temp1));

        // 배열에서 중복 제거하고 복사
        System.out.println(myArray.deleteDuplicate(temp));
        System.out.println(myArray.deleteDuplicate(temp1));

        // 배열을 새롭게 생성하지 않고 뒤집기
        System.out.println(myArray.reverse(temp));
        System.out.println(myArray.reverse(temp1));

        // 두 개의 배열을 연결
        System.out.println(myArray.extend(temp, temp1));

        // 문자열을 받아 각 알파벳 수를 세기
        myArray.countAlpha("MacBookPro14 And Iphone11 And Airpods3");

        // 두 개의 double 배열을 받기
        double temp2 [] = {2.0, 3.0};
        double temp3 [] = {4.1, 1.8};

        System.out.println(myArray.getDoubleArray(temp2, temp3));

        // 두 개의 1차원 행렬 곱 계산
        int t1 [] = {1, 2};
        int t2 [] = {3, 4};
        System.out.println(myArray.matrix1D(t1, t2));

        // 두 개의 행렬을 받아 곱 계산
        int matrix1 [][] = {{1,2}, {3,4}};
        int matrix2 [][] = {{5,6,7}, {8,9,10}};

        System.out.println(myArray.matrixMultiply(matrix1, matrix2));
    }
}




```

</details>

---
### 문제 2 배운것들
- `stream()`을 잘 활용하면 매우 간단하게 원하는 결과를 얻을 수 있다. 
- 자바에서 2차원 배열을 출력하려면 `Arrays.deeptoString()`을 사용하면 됨.
