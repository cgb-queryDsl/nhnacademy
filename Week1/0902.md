# 0902 정리

### 문제 1. Stack 구현.
- LIFO(Last-In-First-Out)으로 가장 마지막에 들어간 데이터가 가장 먼저 나오는 구조.
- 저장된 데이터 중 가장 마지막 데이터만 접근 가능.
<img width="759" alt="스크린샷 2022-09-02 오후 9 47 41" src="https://user-images.githubusercontent.com/87689191/188149214-58baabfb-5a2b-4d6a-a980-a1e8a15c6991.png">

---
### 문제 1.1 Stack 인터페이스를 가지고 ArrayStack 구현

```java
public interface Stack<E> {
    public boolean isEmpty();
    public void push(E element);
    public E pop();
    public E peek();
    public int size();
}
```

### Code

<details>
    <summary>ArrayStack </summary>

```java
import java.util.EmptyStackException;

public class ArrayStack<E> implements Stack<E> {

    final int DEFAULT_SIZE = 100;
    E elements [];
    int top;
    boolean trace;  

    public ArrayStack() {
        this.elements = (E[])new Object[this.DEFAULT_SIZE];
        this.top = -1;
        this.trace = false;
    }

    public ArrayStack(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Stack size is too small");
        }

        this.elements = (E[]) new Object[size];  // 지네릭스 타입으로 생성
        this.top = -1;
        this.trace = false;
    }

    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    @Override
    public boolean isEmpty() {
        return this.top < 0;
    }

    @Override
    public void push(E element) {
        if (this.top < this.elements.length) {
            ++this.top;
            this.elements[this.top] = element;
        }
        if (this.trace) {
            System.out.println(this);
        }
    }

    @Override
    public E pop() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        E value = this.elements[this.top];
        this.top--;

        if (this.trace) {
            System.out.println(this);
        }

        return value;
    }

    @Override
    public E peek() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        return this.elements[this.top];
    }

    @Override
    public int size() {
        return this.top + 1;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        sb.append("Stack :");

        for(int i = 0 ; i <= this.top ; i++) {
            sb.append((sb.length() != 0 ? " ": "") + this.elements[i]);
        }

        return sb.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> ArrayStackTest </summary>

```java
class ArrayStackTest {

    public static void main(String[] args) {
        ArrayStack<Character> stack = new ArrayStack<>();
        stack.setTrace(true);

        stack.push('A');
        stack.push('B');
        stack.push('C');
        stack.pop();
        stack.pop();
        stack.push('D');
        stack.push('E');
        stack.push('F');
        System.out.println("Size : " + stack.size());
        stack.pop();
        stack.push('G');
        stack.pop();
    }
}
```

```java
// 출력
Stack : A
Stack : A B
Stack : A B C
Stack : A B
Stack : A
Stack : A D
Stack : A D E
Stack : A D E F
Size : 4
Stack : A D E
Stack : A D E G
Stack : A D E
```

</details>

---

### 문제 1.2 Stack 인터페이스를 가지고 LinkedStack 구현

### Code

<details>
    <summary> LinkedStack </summary>

```java
import java.util.EmptyStackException;

public class LinkedStack implements Stack<Integer> {

    public static class LinkedNode {
        Integer element;
        LinkedNode next;    // 단방향

        public LinkedNode(Integer element) {
            this.element = element;
            this.next = null;
        }

        public LinkedNode(Integer element, LinkedNode next) {
            this.element = element;
            this.next = next;
        }

        public Integer getElement() {
            return element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getNext() {
            return next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    int count;
    boolean trace;

    public LinkedStack() {
        this.head = null;
        this.count = 0;
        this.trace = false;
    }

    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    @Override
    public boolean isEmpty() {
        return this.count == 0;
    }

    @Override
    public void push(Integer element) {
        this.head = new LinkedNode( element, this.head);
        this.count++;

        if (this.trace) {
            System.out.println(this);
        }
    }

    @Override
    public Integer pop() {
        if (this.size() == 0) {
            throw new EmptyStackException();
        }

        Integer value = this.head.getElement();
        this.head = this.head.getNext();
        this.count--;

        if (this.trace) {
            System.out.println(this);
        }

        return value;
    }

    @Override
    public Integer peek() {
        if (this.size() == 0) {
            throw new EmptyStackException();
        }

        return this.head.getElement();
    }

    @Override
    public int size() {
        return this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();

        LinkedNode node = this.head;
        while(node != null) {
            line.append(((line.length() != 0)?" ":"") + node.getElement());
            node = node.getNext();
        }

        return "LinkedStack : " + line.reverse().toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> LinkedStackTest </summary>

```java
class LinkedStackTest {

    public static void main(String[] args) {
        LinkedStack linkedStack = new LinkedStack();

        linkedStack.setTrace(true);

        linkedStack.push(1);
        linkedStack.push(2);
        linkedStack.push(3);
        linkedStack.pop();
        linkedStack.pop();
        linkedStack.push(9);
        linkedStack.push(8);
        linkedStack.pop();
        linkedStack.pop();
    }
}
```

```java
// 출력
LinkedStack : 1
LinkedStack : 1 2
LinkedStack : 1 2 3
LinkedStack : 1 2
LinkedStack : 1
LinkedStack : 1 9
LinkedStack : 1 9 8
LinkedStack : 1 9
LinkedStack : 1
```

</details>

---

### 문제 1.3 Stack의 데이터를 역순으로 출력

### Code

<details>
    <summary> reversed() </summary>

```java
public String reversed(Stack stack) {
    Stack<Character> newStack = new ArrayStack<>();

    while (!stack.isEmpty()) {
        newStack.push((Character) stack.pop());
    }

    return newStack.toString();
}
```

</details>

---

### 문제 1.4 인수로 주어진 Stack의 데이터를 역순으로 출력하고 원래의 데이터 순서도 그대로 남기기

### Code

<details>
    <summary> reverse() </summary>

```java
public String reverse(Stack stack) {
    Stack<Character> newStack = new ArrayStack<>();
    Stack<Character> tempStack = new ArrayStack<>();

    while (!stack.isEmpty()) {
        Character c = (Character) stack.pop();
        newStack.push(c);
        tempStack.push(c);
    }

    while (!tempStack.isEmpty()) {
        stack.push(tempStack.pop());
    }

    return "원본 " + stack.toString() + "\n역순 " + newStack.toString();
}
```

</details>

---

### 문제 1.5 Stack의 위에서 두번째 데이터 반환

### Code

<details>
    <summary> penultimate() </summary>

```java
public String penultimate(Stack stack) {
    stack.pop();
    Character c = (Character) stack.peek();

    return "위에서 두번째 데이터 : " + c;
}
```

</details>

---

### 문제 1.6 Stack의 위에서 두번째 데이터 반환 후 제거

### Code

<details>
    <summary> popPenultimate() </summary>

```java
public String popPenultimate(Stack stack) {
    StringBuilder sb = new StringBuilder();
    sb.append(stack.toString() + " 에서 제거되는 두 번쨰 데이터는 : ");

    Character temp = (Character) stack.pop();
    Character returnValue = (Character) stack.pop();

    stack.push(temp);

    sb.append(returnValue);
    sb.append("\n결과 " + stack);


    return sb.toString();
}
```

</details>

---

### 문제 1.7 Stack의 제일 아래 데이터 반환

### Code

<details>
    <summary> bottom() </summary>

```java
public String bottom(Stack stack) {
    Character c = null;

    while (!stack.isEmpty()) {
        c = (Character) stack.pop();
    }

    return "제일 아래 데이터 : " + c;
}
```

</details>

---
### 문제 1.8 Stack의 제일 아래 데이터 반환 후 제거

### Code

<details>
    <summary> popBottom() </summary>

```java
public String popBottom(Stack stack) {
    StringBuilder sb = new StringBuilder();
    sb.append(stack.toString() + " 에서 제거되는 제일 아래 데이터는 : ");

    Stack<Character> temp = new ArrayStack<>();
    Character deleteValue = null;

    while (!stack.isEmpty()) {
        temp.push((Character) stack.pop());
    }

    deleteValue = temp.pop();
    sb.append(deleteValue);

    while (!temp.isEmpty()) {
        stack.push(temp.pop());
    }

    sb.append("\n결과" +stack.toString());

    return sb.toString();
}
```

</details>

---
### 전체 ArrayStack Code

<details>
    <summary> ArrayStack </summary>

```java
import java.util.EmptyStackException;

public class ArrayStack<E> implements Stack<E> {

    final int DEFAULT_SIZE = 100;
    E elements [];
    int top;
    boolean trace;  

    public ArrayStack() {
        this.elements = (E[])new Object[this.DEFAULT_SIZE];
        this.top = -1;
        this.trace = false;
    }

    public ArrayStack(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Stack size is too small");
        }

        this.elements = (E[]) new Object[size];  // 지네릭스 타입으로 생성
        this.top = -1;
        this.trace = false;
    }

    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    @Override
    public boolean isEmpty() {
        return this.top < 0;
    }

    @Override
    public void push(E element) {
        if (this.top < this.elements.length) {
            ++this.top;
            this.elements[this.top] = element;
        }
        if (this.trace) {
            System.out.println(this);
        }
    }

    @Override
    public E pop() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        E value = this.elements[this.top];
        this.top--;

        if (this.trace) {
            System.out.println(this);
        }

        return value;
    }

    @Override
    public E peek() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        return this.elements[this.top];
    }

    @Override
    public int size() {
        return this.top + 1;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        sb.append("Stack :");

        for(int i = 0 ; i <= this.top ; i++) {
            sb.append((sb.length() != 0 ? " ": "") + this.elements[i]);
        }

        return sb.toString();
    }

    public String reversed(Stack stack) {
        Stack<Character> newStack = new ArrayStack<>();

        while (!stack.isEmpty()) {
            newStack.push((Character) stack.pop());
        }

        return newStack.toString();
    }

    public String reverse(Stack stack) {
        Stack<Character> newStack = new ArrayStack<>();
        Stack<Character> tempStack = new ArrayStack<>();

        while (!stack.isEmpty()) {
            Character c = (Character) stack.pop();
            newStack.push(c);
            tempStack.push(c);
        }

        while (!tempStack.isEmpty()) {
            stack.push(tempStack.pop());
        }

        return "원본 " + stack.toString() + "\n역순 " + newStack.toString();
    }

    public String penultimate(Stack stack) {
        stack.pop();
        Character c = (Character) stack.peek();

        return "위에서 두번째 데이터 : " + c;
    }

    public String popPenultimate(Stack stack) {
        StringBuilder sb = new StringBuilder();
        sb.append(stack.toString() + " 에서 제거되는 두 번쨰 데이터는 : ");

        Character temp = (Character) stack.pop();
        Character returnValue = (Character) stack.pop();

        stack.push(temp);

        sb.append(returnValue);
        sb.append("\n결과 " + stack);


        return sb.toString();
    }

    public String bottom(Stack stack) {
        Character c = null;

        while (!stack.isEmpty()) {
            c = (Character) stack.pop();
        }

        return "제일 아래 데이터 : " + c;
    }

    public String popBottom(Stack stack) {
        StringBuilder sb = new StringBuilder();
        sb.append(stack.toString() + " 에서 제거되는 제일 아래 데이터는 : ");

        Stack<Character> temp = new ArrayStack<>();
        Character deleteValue = null;

        while (!stack.isEmpty()) {
            temp.push((Character) stack.pop());
        }

        deleteValue = temp.pop();
        sb.append(deleteValue);

        while (!temp.isEmpty()) {
            stack.push(temp.pop());
        }

        sb.append("\n결과" +stack.toString());

        return sb.toString();
    }
}
```
</details>

<br/>

### 전체 Test Code

<details>
    <summary> ArrayStackTest </summary>

```java
class ArrayStackTest {

    public static void main(String[] args) {
        ArrayStack<Character> stack = new ArrayStack<>();
        stack.setTrace(true);

        stack.push('A');
        stack.push('B');
        stack.push('C');
        stack.pop();
        stack.pop();
        stack.push('D');
        stack.push('E');
        stack.push('F');
        System.out.println("Size : " + stack.size());
        stack.pop();
        stack.push('G');
        stack.pop();

        System.out.println("======");
        stack.setTrace(false);
        System.out.println(stack.reversed(stack));

        System.out.println("======");

        ArrayStack<Character> stack1 = new ArrayStack<>();
        stack1.push('A');
        stack1.push('B');
        stack1.push('C');

        System.out.println(stack1.reverse(stack1));

        System.out.println("======");
        System.out.println(stack1.penultimate(stack1));

        System.out.println("======");
        stack1.push('C');
        System.out.println(stack1.popPenultimate(stack1));

        System.out.println("======");
        stack1.push('E');
        System.out.println(stack1.bottom(stack1));

        System.out.println("======");
        ArrayStack<Character> stack2 = new ArrayStack<>();
        stack2.push('D');
        stack2.push('E');
        stack2.push('F');
        System.out.println(stack2.popBottom(stack2));
    }
}
```

```java
// 출력
Stack : A
Stack : A B
Stack : A B C
Stack : A B
Stack : A
Stack : A D
Stack : A D E
Stack : A D E F
Size : 4
Stack : A D E
Stack : A D E G
Stack : A D E
======
Stack : E D A
======
원본 Stack : A B C
역순 Stack : C B A
======
위에서 두번째 데이터 : B
======
Stack : A B C 에서 제거되는 두 번쨰 데이터는 : B
결과 Stack : A C
======
제일 아래 데이터 : A
======
Stack : D E F 에서 제거되는 제일 아래 데이터는 : D
결과Stack : E F
```

</details>

---
### 문제 1 배운것들
- `Stack`은 먼저 들어온 값이 제일 나중에 나가는 구조.
- LinkedList로 구현하려면 [LinkedNode](#문제-12-stack-인터페이스를-가지고-linkedstack-구현) class를 따로 구현해야함.
- [LinkedStack](#문제-12-stack-인터페이스를-가지고-linkedstack-구현) push & pop과정을 그림으로 표현.

- ![제목 없는 다이어그램 drawio](https://user-images.githubusercontent.com/87689191/188263547-253b16b5-6715-4154-9072-32dc45e92aaf.png)  
    - ```java
        // 핵심 코드 
        this.head = new LinkedNode( element, this.head);
        this.count++;
        ```
    - this.head에 새로운 노드 객체를 생성(값 생성, next는 기존 this.head)
    - 자연스럽게 this.head는 다음 객체를 가르키고 있음.

    <br/>

- ![제목 없는 다이어그램 drawio (1)](https://user-images.githubusercontent.com/87689191/188264171-d43e560c-02cf-4feb-9146-f373ca2aae60.png)
    - ```java
        Integer value = this.head.getElement();
        this.head = this.head.getNext();
        this.count--;
        ```
    - this.head는 최상위에 위치하고 있는 곳을 가르키고 있기 때문에 pop()할 원소는 this.head.getElement()로 값을 가져올 수 있다.
    - 원소를 하나 지우기 때문에 this.head를 아래의 데이터를 가르키게 옮겨줘야 한다.
    - 그림에서 보면 next는 스택에서 항상 아래의 값을 가르키고 있다.
    - 따라서 this.head.getNext()로 this.head가 가르키는 방향을 바꿔주기만 하면 된다.



<br/>

### 문제 1 후기
- Stack 자료구조는 가장 기본적이면서도 많이 사용하기에 알고있던 내용이기도 해서 쉽게 문제를 풀었다.
- 다만 `LinkedStack`을 구현할 때 바로 위에 적은 push() & pop() 과정을 이해하는데 시간이 걸렸다. 그림을 그려보고 천천히 과정들을 생각하며 이해했다.

<br/>

**이해 점수** : 4.3 / 5

---

### 문제 2. Queue 구현.
- FIFO(First-In-First-Out)으로 먼저 저장한 데이터가 먼저 나오는 구조.
- 저장된 데이터 중 가장 앞에 있는 데이터만 접근 가능.

<img width="703" alt="스크린샷 2022-09-02 오후 10 07 09" src="https://user-images.githubusercontent.com/87689191/188152571-4b7c9166-46a4-4938-b696-385584809f75.png">


---
### 문제 2.1 Queue 인터페이스를 가지고 ArrayQueue 구현

```java
public interface Queue {
    public boolean isEmpty();
    public void add(Integer element);
    public Integer element();
    public Integer remove();
    public int size();
}
```

### Code

<details>
    <summary> ArrayQueue </summary>

```java
public class ArrayQueue implements Queue {

    final int DEFAULT_SIZE = 100;
    Integer elements [];
    int head;
    int tail;


    public ArrayQueue() {
        this.elements = new Integer[this.DEFAULT_SIZE];
        this.head = 0;
        this.tail = 0;
    }

    public ArrayQueue(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Queue size is too small");
        }

        this.elements = new Integer[size];
        this.head = 0;
        this.tail = 0;
    }


    @Override
    public boolean isEmpty() {
        return this.head == this.tail;
    }

    @Override
    public void add(Integer element) {
        this.elements[this.tail] = element;
        this.tail++;
    }

    @Override
    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return this.elements[this.head];
    }

    @Override
    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        Integer value = this.elements[this.head];
        this.head++;

        return value;
    }

    @Override
    public int size() {
        // 회전큐에서 이렇게 구현
        return (this.DEFAULT_SIZE + this.tail - this.head) % DEFAULT_SIZE;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();

        int node = this.head;
        while(node != this.tail) {

            line.append((line.length() != 0?" ":"") + this.elements[node]);
            node++;
        }

        return line.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> ArrayQueueTest </summary>

```java
class ArrayQueueTest {

    public static void main(String[] args) {
        Queue q = new ArrayQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---
### 문제 2.2 Queue 인터페이스를 가지고 LinkedQueue 구현

### Code

<details>
    <summary> LinkedQueue </summary>

```java
public class LinkedQueue implements Queue{

    static class LinkedNode {
        Integer element;
        LinkedNode next;   

        public LinkedNode(Integer element) {
            this.element = element;
            this.next = null;
        }

        public LinkedNode(Integer element, LinkedNode next) {
            this.element = element;
            this.next = next;
        }

        public Integer getElement() {
            return element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getNext() {
            return next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    LinkedNode tail;
    int count;

    public LinkedQueue() {
        this.head = null;
        this.tail = null;
        this.count = 0;
    }

    @Override
    public boolean isEmpty() {
        return this.count == 0;
    }

    @Override
    public void add(Integer element) {
        if (this.isEmpty()) {
            this.head = new LinkedNode((Integer) element, null);
            this.tail = this.head;
        } else {
            this.tail.setNext(new LinkedNode((Integer) element, null));
            this.tail = this.tail.getNext();
        }
        this.count++;
    }

    @Override
    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return this.head.getElement();
    }

    @Override
    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        Integer element = this.head.getElement();

        if (this.count == 1) {
            this.head = null;
            this.tail = null;
        } else {
            this.head = this.head.getNext();
        }

        this.count--;

        return element;
    }

    @Override
    public int size() {
        return this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();
        LinkedNode node = this.head;

        while(node != null) {
            line.append((line.length() != 0?" ":"") + node.getElement());
            node = node.getNext();
        }

        return line.toString();
    }
}
```
</details>

<br/>

### Test Code

<details>
    <summary> LinkedQueueTest </summary>

```java
class LinkedQueueTest {

    public static void main(String[] args) {
        Queue q = new LinkedQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---
### 문제 2 (번외) Queue 인터페이스를 가지고 DoubleLinkedQueue 구현

### Code

<details>
    <summary> DoubleLinkedQueue </summary>

```java
public class DoubleLinkedQueue implements Queue {

    static class LinkedNode {
        Integer element;
        LinkedNode previous;
        LinkedNode next;

        public LinkedNode() {
            this.element = 0;
            this.previous = this;
            this.next = this;
        }

        public LinkedNode(Integer element, LinkedNode previous, LinkedNode next) {
            this.element = element;
            this.previous = previous;
            this.next = next;
        }

        public Integer getElement() {
            return	this.element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getPrevious() {
            return	this.previous;
        }

        public void setPrevious(LinkedNode previous) {
            this.previous = previous;
        }

        public LinkedNode getNext() {
            return	this.next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    int count;

    public DoubleLinkedQueue() {
        this.head = new LinkedNode();
        this.count = 0;
    }

    public boolean isEmpty() {
        //return	this.count == 0;
        return (this.head.getNext() == this.head);
    }

    public void add(Integer element) {
        LinkedNode newNode = new LinkedNode(element, this.head.getPrevious(), this.head);
        this.head.getPrevious().setNext(newNode);
        this.head.setPrevious(newNode);
        this.count++;
    }

    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return	this.head.getNext().getElement();
    }

    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        LinkedNode target = this.head.getNext();

        Integer element = target.getElement();

        target.getPrevious().setNext(target.getNext());
        target.getNext().setPrevious(target.getPrevious());
        this.count--;

        return	element;
    }

    public int size() {
        return	this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();
        LinkedNode node = this.head.getNext();

        while(node != this.head) {
            line.append((line.length() != 0?" ":"") + node.getElement());
            node = node.getNext();
        }

        return	line.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> DoubleLinkedQueueTest </summary>

```java
class DoubleLinkedQueueTest {

    public static void main(String[] args) {
        Queue q = new DoubleLinkedQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---

### 문제 2.3 ⭐️⭐️⭐️⭐️⭐️

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>

<details>
    <summary>  </summary>

```java

```

</details>
