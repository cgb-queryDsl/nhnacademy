# 0902 정리

### 문제 1. Stack 구현.
- LIFO(Last-In-First-Out)으로 가장 마지막에 들어간 데이터가 가장 먼저 나오는 구조.
- 저장된 데이터 중 가장 마지막 데이터만 접근 가능.
<img width="759" alt="스크린샷 2022-09-02 오후 9 47 41" src="https://user-images.githubusercontent.com/87689191/188149214-58baabfb-5a2b-4d6a-a980-a1e8a15c6991.png">

---
### 문제 1.1 Stack 인터페이스를 가지고 ArrayStack 구현

```java
public interface Stack<E> {
    public boolean isEmpty();
    public void push(E element);
    public E pop();
    public E peek();
    public int size();
}
```

### Code

<details>
    <summary>ArrayStack </summary>

```java

import java.util.EmptyStackException;

public class ArrayStack<E> implements Stack<E> {

    final int DEFAULT_SIZE = 100;
    E elements [];
    int top;
    boolean trace;  

    public ArrayStack() {
        this.elements = (E[])new Object[this.DEFAULT_SIZE];
        this.top = -1;
        this.trace = false;
    }

    public ArrayStack(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Stack size is too small");
        }

        this.elements = (E[]) new Object[size];  // 지네릭스 타입으로 생성
        this.top = -1;
        this.trace = false;
    }

    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    @Override
    public boolean isEmpty() {
        return this.top < 0;
    }

    @Override
    public void push(E element) {
        if (this.top < this.elements.length) {
            ++this.top;
            this.elements[this.top] = element;
        }
        if (this.trace) {
            System.out.println(this);
        }
    }

    @Override
    public E pop() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        E value = this.elements[this.top];
        this.top--;

        if (this.trace) {
            System.out.println(this);
        }

        return value;
    }

    @Override
    public E peek() {
        if (this.size() < 0) {
            throw new EmptyStackException();
        }

        return this.elements[this.top];
    }

    @Override
    public int size() {
        return this.top + 1;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        sb.append("Stack :");

        for(int i = 0 ; i <= this.top ; i++) {
            sb.append((sb.length() != 0 ? " ": "") + this.elements[i]);
        }

        return sb.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> ArrayStackTest </summary>

```java
class ArrayStackTest {

    public static void main(String[] args) {
        ArrayStack<Character> stack = new ArrayStack<>();
        stack.setTrace(true);

        stack.push('A');
        stack.push('B');
        stack.push('C');
        stack.pop();
        stack.pop();
        stack.push('D');
        stack.push('E');
        stack.push('F');
        System.out.println("Size : " + stack.size());
        stack.pop();
        stack.push('G');
        stack.pop();
    }
}
```

```java
// 출력
Stack : A
Stack : A B
Stack : A B C
Stack : A B
Stack : A
Stack : A D
Stack : A D E
Stack : A D E F
Size : 4
Stack : A D E
Stack : A D E G
Stack : A D E
```

</details>

---

### 문제 1.2 Stack 인터페이스를 가지고 LinkedStack 구현

### Code

<details>
    <summary> LinkedStack </summary>

```java
import java.util.EmptyStackException;

public class LinkedStack implements Stack<Integer> {

    public static class LinkedNode {
        Integer element;
        LinkedNode next;    // 단방향

        public LinkedNode(Integer element) {
            this.element = element;
            this.next = null;
        }

        public LinkedNode(Integer element, LinkedNode next) {
            this.element = element;
            this.next = next;
        }

        public Integer getElement() {
            return element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getNext() {
            return next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    int count;
    boolean trace;

    public LinkedStack() {
        this.head = null;
        this.count = 0;
        this.trace = false;
    }

    public void setTrace(boolean trace) {
        this.trace = trace;
    }

    @Override
    public boolean isEmpty() {
        return this.count == 0;
    }

    @Override
    public void push(Integer element) {
        this.head = new LinkedNode( element, this.head);
        this.count++;

        if (this.trace) {
            System.out.println(this);
        }
    }

    @Override
    public Integer pop() {
        if (this.size() == 0) {
            throw new EmptyStackException();
        }

        Integer value = this.head.getElement();
        this.head = this.head.getNext();
        this.count--;

        if (this.trace) {
            System.out.println(this);
        }

        return value;
    }

    @Override
    public Integer peek() {
        if (this.size() == 0) {
            throw new EmptyStackException();
        }

        return this.head.getElement();
    }

    @Override
    public int size() {
        return this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();

        LinkedNode node = this.head;
        while(node != null) {
            line.append(((line.length() != 0)?" ":"") + node.getElement());
            node = node.getNext();
        }

        return "LinkedStack : " + line.reverse().toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> LinkedStackTest </summary>

```java
class LinkedStackTest {

    public static void main(String[] args) {
        LinkedStack linkedStack = new LinkedStack();

        linkedStack.setTrace(true);

        linkedStack.push(1);
        linkedStack.push(2);
        linkedStack.push(3);
        linkedStack.pop();
        linkedStack.pop();
        linkedStack.push(9);
        linkedStack.push(8);
        linkedStack.pop();
        linkedStack.pop();
    }
}
```

```java
// 출력
LinkedStack : 1
LinkedStack : 1 2
LinkedStack : 1 2 3
LinkedStack : 1 2
LinkedStack : 1
LinkedStack : 1 9
LinkedStack : 1 9 8
LinkedStack : 1 9
LinkedStack : 1
```

</details>

---

### 문제 1.3 ⭐️⭐️⭐️⭐️⭐️

---

### 문제 2. Queue 구현.
- FIFO(First-In-First-Out)으로 먼저 저장한 데이터가 먼저 나오는 구조.
- 저장된 데이터 중 가장 앞에 있는 데이터만 접근 가능.

<img width="703" alt="스크린샷 2022-09-02 오후 10 07 09" src="https://user-images.githubusercontent.com/87689191/188152571-4b7c9166-46a4-4938-b696-385584809f75.png">

---
### 문제 2.1 Queue 인터페이스를 가지고 ArrayQueue 구현

```java
public interface Queue {
    public boolean isEmpty();
    public void add(Integer element);
    public Integer element();
    public Integer remove();
    public int size();
}
```

### Code

<details>
    <summary> ArrayQueue </summary>

```java
public class ArrayQueue implements Queue {

    final int DEFAULT_SIZE = 100;
    Integer elements [];
    int head;
    int tail;


    public ArrayQueue() {
        this.elements = new Integer[this.DEFAULT_SIZE];
        this.head = 0;
        this.tail = 0;
    }

    public ArrayQueue(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Queue size is too small");
        }

        this.elements = new Integer[size];
        this.head = 0;
        this.tail = 0;
    }


    @Override
    public boolean isEmpty() {
        return this.head == this.tail;
    }

    @Override
    public void add(Integer element) {
        this.elements[this.tail] = element;
        this.tail++;
    }

    @Override
    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return this.elements[this.head];
    }

    @Override
    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        Integer value = this.elements[this.head];
        this.head++;

        return value;
    }

    @Override
    public int size() {
        // 회전큐에서 이렇게 구현
        return (this.DEFAULT_SIZE + this.tail - this.head) % DEFAULT_SIZE;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();

        int node = this.head;
        while(node != this.tail) {

            line.append((line.length() != 0?" ":"") + this.elements[node]);
            node++;
        }

        return line.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> ArrayQueueTest </summary>

```java
class ArrayQueueTest {

    public static void main(String[] args) {
        Queue q = new ArrayQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---
### 문제 2.2 Queue 인터페이스를 가지고 LinkedQueue 구현

### Code

<details>
    <summary> LinkedQueue </summary>

```java
public class LinkedQueue implements Queue{

    static class LinkedNode {
        Integer element;
        LinkedNode next;   

        public LinkedNode(Integer element) {
            this.element = element;
            this.next = null;
        }

        public LinkedNode(Integer element, LinkedNode next) {
            this.element = element;
            this.next = next;
        }

        public Integer getElement() {
            return element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getNext() {
            return next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    LinkedNode tail;
    int count;

    public LinkedQueue() {
        this.head = null;
        this.tail = null;
        this.count = 0;
    }

    @Override
    public boolean isEmpty() {
        return this.count == 0;
    }

    @Override
    public void add(Integer element) {
        if (this.isEmpty()) {
            this.head = new LinkedNode((Integer) element, null);
            this.tail = this.head;
        } else {
            this.tail.setNext(new LinkedNode((Integer) element, null));
            this.tail = this.tail.getNext();
        }
        this.count++;
    }

    @Override
    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return this.head.getElement();
    }

    @Override
    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        Integer element = this.head.getElement();

        if (this.count == 1) {
            this.head = null;
            this.tail = null;
        } else {
            this.head = this.head.getNext();
        }

        this.count--;

        return element;
    }

    @Override
    public int size() {
        return this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();
        LinkedNode node = this.head;

        while(node != null) {
            line.append((line.length() != 0?" ":"") + node.getElement());
            node = node.getNext();
        }

        return line.toString();
    }
}
```
</details>

<br/>

### Test Code

<details>
    <summary> LinkedQueueTest </summary>

```java
class LinkedQueueTest {

    public static void main(String[] args) {
        Queue q = new LinkedQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---
### 문제 2 (번외) Queue 인터페이스를 가지고 DoubleLinkedQueue 구현

### Code

<details>
    <summary> DoubleLinkedQueue </summary>

```java
public class DoubleLinkedQueue implements Queue {

    static class LinkedNode {
        Integer element;
        LinkedNode previous;
        LinkedNode next;

        public LinkedNode() {
            this.element = 0;
            this.previous = this;
            this.next = this;
        }

        public LinkedNode(Integer element, LinkedNode previous, LinkedNode next) {
            this.element = element;
            this.previous = previous;
            this.next = next;
        }

        public Integer getElement() {
            return	this.element;
        }

        public void setElement(Integer element) {
            this.element = element;
        }

        public LinkedNode getPrevious() {
            return	this.previous;
        }

        public void setPrevious(LinkedNode previous) {
            this.previous = previous;
        }

        public LinkedNode getNext() {
            return	this.next;
        }

        public void setNext(LinkedNode next) {
            this.next = next;
        }
    }

    LinkedNode head;
    int count;

    public DoubleLinkedQueue() {
        this.head = new LinkedNode();
        this.count = 0;
    }

    public boolean isEmpty() {
        //return	this.count == 0;
        return (this.head.getNext() == this.head);
    }

    public void add(Integer element) {
        LinkedNode newNode = new LinkedNode(element, this.head.getPrevious(), this.head);
        this.head.getPrevious().setNext(newNode);
        this.head.setPrevious(newNode);
        this.count++;
    }

    public Integer element() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }

        return	this.head.getNext().getElement();
    }

    public Integer remove() {
        if (this.isEmpty()) {
            throw new java.util.NoSuchElementException();
        }
        LinkedNode target = this.head.getNext();

        Integer element = target.getElement();

        target.getPrevious().setNext(target.getNext());
        target.getNext().setPrevious(target.getPrevious());
        this.count--;

        return	element;
    }

    public int size() {
        return	this.count;
    }

    @Override
    public String toString() {
        StringBuilder line = new StringBuilder();
        LinkedNode node = this.head.getNext();

        while(node != this.head) {
            line.append((line.length() != 0?" ":"") + node.getElement());
            node = node.getNext();
        }

        return	line.toString();
    }
}
```

</details>

<br/>

### Test Code

<details>
    <summary> DoubleLinkedQueueTest </summary>

```java
class DoubleLinkedQueueTest {

    public static void main(String[] args) {
        Queue q = new DoubleLinkedQueue();
        q.add(1);
        System.out.println("Queue : " + q);
        q.add(2);
        System.out.println("Queue : " + q);
        q.add(3);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(4);
        System.out.println("Queue : " + q);
        q.add(5);
        System.out.println("Queue : " + q);
        q.add(6);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.add(7);
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
        System.out.println("Queue : " + q);
        q.remove();
    }
}
```

```java
// 출력
Queue : 1
Queue : 1 2
Queue : 1 2 3
Queue : 2 3
Queue : 3
Queue : 3 4
Queue : 3 4 5
Queue : 3 4 5 6
Queue : 4 5 6
Queue : 4 5 6 7
Queue : 5 6 7
Queue : 6 7
```

</details>

---

### 문제 2.3 ⭐️⭐️⭐️⭐️⭐️