# 1109 정리


### 관계 모델
---

### 관계 모델 개요
- 1970년 Dr.Codd에 의해 제안된 데이터 모델
- DB2, Oracle, MSSSQL Server, MySQL 등 많은 DBMS 모델
- 관계 논리식과 관계 대수식에 기반한 데이터 조회 및 저장
- 데이터베이스는 하나 이상의 릴레리션의 집합으로 테이블 형식으로 데이터 표현
- 데이터베이스를 제어하는 고수준의 언어를 사용하여 데이터의 표현과 복잡한 질의를 쉽게 처리
- 관계형 데이터베이스가 지켜야할 조건 : Dr.Codd의 12규칙

<br/>

### Dr.Codd의 12법칙
- 규칙 0. 시스템은 데이터베이스뿐만 아니라 관리 시스템으로써 관계 모델의 자격을 얻어야 한다.
- 규칙 1. "정보규칙" - 데이터베이스 내의 모든 정보는 한 가지 방법으로만 표시되어야 한다.
- 규칙 2. "보장된 접근 규칙" - 모든 데이터는 모호함이 없이 접근되어야 한다.
- 규칙 3. "널 값의 체계적인 처리" - DBMS는 각 필드에 대해 null을 처리할 수 있어야 한다.
- 규칙 4. "관계형 모델에 기반한 액티브 온라인 데이터베이스 카탈로그" - 시스템은 관계형 형태의 온라인 카탈로그를 제공해야 한다.
- 규칙 5. "종합적인 데이터 보조언어 규칙" - 시스템은 적어도 하나의 관계형 언어를 지원해야 한다.
- 규칙 6. "뷰 갱신 규칙" - 뷰는 시스템에 의해 갱신 가능해야 한다.
- 규칙 7. "고급 삽입, 갱신, 제거" - 시스템은 집합에 대해 한번에 삽입, 갱신, 제거를 지원해야 한다.
- 규칙 8. "물리적 데이터 독립성" - 물리적 레벨에서 변경이 일어나더라고 그 구조에 기반한 응용 프로그램은 변경되어서는 안된다.
- 규칙 9. "논리적 데이터 독립성" - 논리적 레벨에서 변경이 일어나더라고 그 구조에 기반한 응용 프로그램은 변경되어서는 안된다.
- 규칙 10. "무결성 독립성" - 무결성 제약조건들은 데이터베이스 카탈로그에 저장되어야 하며 응용 프로그램들과는 별도로 규정되어야 한다.
- 규칙 11. "분산 독립성" - 데이터베이스의 분산은 데이터베이스 사용자에게 영향을 주지 않는다.
- 규칙 12. "무전복 규칙" - 시스템이 저급 인터페이스를 제공하더라고, 그 인터페이스는 시스템을 파괴할 수 없어야 한다.

<br/>

### 관계형 데이터베이스 시스템 역사

<img width="697" alt="image" src="https://user-images.githubusercontent.com/87689191/201503759-6d17723c-2252-4ae7-9d9f-865739c9347b.png">

---

### 릴레이션 스키마
- 관계 모델에서 릴레이션 스키마는 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 의미
- 개체와 개체의 특성을 나타내는 속성, 관계, 제약조건을 기술한 것
- 명세
    - 릴레이션 이름
    - 필드 또는 열(Column) 또는 속성(Attribute)
    - 각 속성의 도메인

<img width="665" alt="image" src="https://user-images.githubusercontent.com/87689191/201503815-b5a7a44d-aa13-4b8b-b2c9-9c4bb8f80859.png">

<br/>

### 릴레이션 인스턴스
- 레코드라고 불리는 투플의 집합
- 투플
    - 각 속성으로 정의되며 하나의 데이터 묶음
    - 각 투플의 하나의 행으로 구성
- 투플 수 : 카디널리티
- 속성 수 : 차수
- 투플 순서는 중요하지 않음

<img width="698" alt="image" src="https://user-images.githubusercontent.com/87689191/201503859-449dbfd3-ce1d-4350-adfd-b902a12f0fdd.png">

<br/>

### 도메인
- 하나의 속성이 가질 수 있는 동일한 유형의 원자값들의 집합
- 릴레이션 스키마는 릴레이션 인스턴스의 각 필드의 도메인을 명세
    - 도메인 제약조건 : 인스턴스가 지켜야 하는 중요한 조건
- 프로그래밍 언어 관점에서 필드의 데이터 타입을 의미

<br/>

### 관계형 데이터베이스
- 관계형 데이터베이스
    - 서로 다른 릴레이션 이름을 가진 릴레이션들의 모임
- 관계형 데이터베이스 스키마
    - 데이터베이스에 속한 릴레이션의 스키마들의 집합

<br/>

### MySQL 릴레이션 실습
- 생성
```sql
mysql > CREATE TABLE Category (
    -> CategoryNo INTEGER,
    -> CategoryName VARCHAR(20)
);
```
```sql
mysql > CREATE TABLE Product (
    -> ProductNo INTEGER,
    -> ProductName NVARCHAR(30),
    -> Price DECIMAL,
    -> CategoryNo INTEGER
);
```
- 삽입 / 조회 / 수정
```sql
mysql > INSERT INTO Category VALUES (1, 'Novel');
mysql > INSERT INTO Category VALUES (2, 'Poem');
```
```sql
mysql > UPDATE Category SET
    -> CategoryName = 'History'
    -> WHERE CategoryNo = 1;
```

<br/>

### 무결성 제약조건
- 저장된 정보의 품질에 따라 데이터베이스의 품질이 결정됨
- 무결성 제약조건  
    - 데이터베이스 스키마에 명세되어 있는 조건
    - 데이터베이스 인스턴스에 저장될 수 있는 데이터를제한 
- 적법한 인스턴스
    - 스키마에 명세 된 무결성 제약조건을 모두 만족하는 데이터베이스 인스턴스

<br/>

### 개채 무결성
- 한 개체(투플)은 다른 개체들과 명확히 구분되어야 함
- 모든 릴레이션에 속한 필드들의 최소 부분집합이 각 투플에 고유 시별자가 되어야 함
- 키 제약조건으로 개체 무결성을 유지
    - 키 제약조건에서 투플을 식별하는 부분집합을 `키`라고 함
- 수퍼키
    - 유일성을 만족하는 필드들의 부분 집합
- 후보키
    - 유일성과 최소성을 만족하는 수퍼키 집합의 부분 집합
- 기본키
    - 특정 투플을 구별하기 위해 후보키에서 선택된 고유한 식별자

<br/>


### 참조 무결성
- 한 릴레이션에 저장된 정보와 다른 릴레이션에 정보와 연결되는 경우가 대부분
- 참조 관계에 있는 데이터는 항상 일관된 갑으로 유지되어야 함
    - 한 데이터가 수정되면 참조 관계에 있는 데이터도 수정
    - 한 데이터가 삭제되면 참조 관계에 있는 데이터도 삭제
- 외래키 제약조건으로 참조 무결성을 유지
    - 한 릴레이션의 필드가 다른 릴레이션의 키를 참조
    - 참조하는 릴레이션의 데이터 변경에 따른 무결성을 유지
- 외래키
    - 다른 릴레이션의 투플을 유일하게 식별하는 키
    - 다를 릴레이션의 투플을 참조하기 위해 사용

<Br/>

### 도메인 무결성
- 필드에는 일관된 데이터가 저장되어야 함
- 지정된 형식이 아닌 다른 형식의 데이터는 포함될 수 없어야 함
- 도메인 제약조건으로 도메인 무결성 유지
    - 각 속성의 값은 반드시 원자값
    - 속성에 지정된 도메인의 범위 내에 해당하는 값
    - 기본 값과 null 포함 가능 여부등에 대한 제약조건

<br/>

### 무결성 제약조건 집행
- 스키마에 정의되고 릴레이션이 수정될 때 집행
- 도메인, 개채 무결성은 직관적으로 즉시 집행
    - 제약조건을 위배하는 삽입, 삭제, 갱신은 즉시 거부
- 참조 무결성 집행 단계
    - 참조하는 릴레이션에 없는 값에 대한 삽입
        - 명령이 거부
    - 참조하는 릴레이션의 데이터가 삭제되는 경우
        - 외래키가 존재하는 릴레이션 참조 데이터를 모두 삭제
        - 참조 릴레이션의 데이터를 삭제할 수 없도록 명령을 거부
        - 외래키가 존재하는 릴레이션의 해당 데이터를 모두 다른 값으로 경신

<Br/>

### SQL
- DDL
    - CREATE, ALTER, DROP
- DML
    - SELECT, INSERT, UPDATE, DELETE
- DCL
    - GRANT, DENY, REVOKE

<br/>


---
## 디스크와 파일

<br/>

### 디스크와 파일 개요

<img width="672" alt="image" src="https://user-images.githubusercontent.com/87689191/201504651-2b6e49c2-27a7-45d3-bd48-5137110c337d.png">

<br/>

### 기억장치 계층 구조
- 컴퓨터 시스템의 기억장치는 계층적으로 구성

<img width="634" alt="image" src="https://user-images.githubusercontent.com/87689191/201504696-2a0176ac-d532-49dc-bb5b-c8ecefec5fab.png">

- 1차 저장장치
    - 레지스터, 캐시, 주 기억장치
- 2차 저장장치
    - SSD, 자기 디스크
- 3차 저장장치
    - 테이프

<Br/>

### HDD
- 기계 장치가 포함된 저장장치로, 자기를 이용하여 데이터를 저장하고 읽음
- 순차 접근 방식이 아닌 직접 접근 방식

<img width="668" alt="image" src="https://user-images.githubusercontent.com/87689191/201504832-c59ff764-e49a-48b1-a0a5-8b4446ebb7c0.png">

- 데이터는 디스크 내의 `디스크 블록`단위로 저장
- 블록은 하나 이상의 `플래터`에서 트랙이란 동심원을 따라 배치
- 플래터들이 모여 `실린더`
- 각각의 트랙은 `섹터`

<br/>

### SDD
- 플래시 메모리를 기반으로 한 저장 매체
- Random Access 가능한 빠른 속도의 저장 장치
- 모든 구성요소가 전기장치

<img width="652" alt="image" src="https://user-images.githubusercontent.com/87689191/201504918-50e32f45-021d-4df2-aac3-4d8da0cffa8b.png">

<br/>

### 디스크의 성능
- HDD
    - DBMS가 작업을 수행하려면 데이터는 주 기억장치에 있어야 함
    - HDD의 경우 전송 단위는 블록
    - 블록 내의 항목 중 하나만 필요한 경우라도 블록 또는 페이지의 전체 데이터가 전송되어야 함
    - 접근 시간 = 탐색시간 + 회전 지연 시간 + 전송 시간
- SDD
    - HDD와 다르게 전송 시간만 소요되므로 일정한 응답 속도가 보장됨
    - 쓰기의 경우 비어있는 공간이 없으면 공간을 초기화
    - 해당 공간에 대한 I/O 작업이 대기 상태

<br/>

### 비어 있는 블록의 추적 감시
- 레코드를 삽입함에 따라 데이터베이스가 확장되고 축소됨
- DBMS는 사용중인 디스크 블록과 어떤 블록에 존재하는지 추적 감시
- 추적 감시
    - 비어있는 블록들의 리스트 유지

<br/>

### 버퍼 풀
- 가용한 주 기억장치 공간을 페이지라는 단위로 분할한 데이터 적재 공간

<img width="608" alt="image" src="https://user-images.githubusercontent.com/87689191/201505198-5379d60b-adfe-4b47-bb32-65ea2ac79ef3.png">

- 버퍼 풀내의 페이지 : 프레임
- `pin_count`, `dirty` 두 개의 변수를 유지하여 관리
- `pin_count` : 현재 프레임 내에 있는 페이지를 사용하고 있는 사용자 수
    - `Pinning` : count 증가
    - `Unpinning` : count 감소
- `dirty` : 값이 변경되어있는 체크하는 boolean 값


<Br/>

### 버퍼 교체 전략
- LRU
- Clock
- FIFO, MRU 등

<br/>

### 버퍼 관리 기법 비교
- 운영체제의 가상 메모리와 DBMS 버퍼 관리자는 매우 비슷
- DBMS는 운영체제 환경보다 더 정확히 예측해야 함
- DBMS는 페이지를 디스크에 강제 출력할 수 있어야 함

<br/>

### 고정 길이 레코드
- 각 필드의 길이가 고정적이고 필드의 수도 고정된 레코드 형식
- 필드를 레코드에 연속적으로 저장
- 대부분의 경우에서 항상 빠름

<img width="638" alt="image" src="https://user-images.githubusercontent.com/87689191/201506930-f6c3a5bc-4627-4a0e-939b-2c4ac3e44ccb.png">

<br/>

### 가변 길이 레코드
- 필드의 길이가 가변적인 경우 해당 레코드의 길이가 가변적이 됨
- 구분 2가지 방법
    - 필드를 `분리자`로 구분하여 연속적으로 저장
    - 레코드의 앞부분에 정수로 된 `오프셋`들을 배열로 저장

<br/>

### 페이지 형식
- 페이지는 레코드가 탑재되는 슬롯의 모임으로 생각
- 레코드는 <페이지 번호, 슬롯 번호>의 쌍으로 식별
- <페이지 번호, 슬롯 번호>의 쌍을 RID &lt;Record ID&gt; 라고 하며, 레코드의 포인터 역할

<br/>

### 고정 길이 레코드
- 고정 길이 레코드에만 탑재 될 경우 슬롯은 같은 형태, 연속적으로 배치 가능
- 레코드가 페이지로 삽입될 때는 빈 슬롯을 할당하고 할당된 슬롯에 레코드를 삽입
- 빈 슬롯을 어떻게 알 수 있는지에 대한 2가지 방법

<img width="573" alt="image" src="https://user-images.githubusercontent.com/87689191/201507057-eb81ccbb-72c1-438c-95f1-b7c4dded083e.png">

<br/>

### 가변 길이 레코드
- 레코드가 가변 길이이면 페이지를 고정된 길이의 슬롯으로 분할할 수 없음
- 슬롯 마다 <레코드 오프셋, 레코드 길이>의 형태로 슬롯 디렉토리를 유지
- 빈 공간의 시간을 가르키는 포인터 유지

<img width="304" alt="image" src="https://user-images.githubusercontent.com/87689191/201507101-91bfb720-d709-4024-b7e9-ad12fe4e75a6.png">

<br/>

### 힙 파일
- 가장 간단한 파일 구조, 레코드가 파일의 빈 공간에 순서 없이 저장
- 페이지 내의 데이터가 어떠한 형태로도 정렬되지 않으며 파일의 모든 레코드를 검색하면 다음 레코드를 되풀이해서 요청해야 함
- 파일의 레코드는 각기 유일한 rid를 가지며 한 파일에 속하는 페이지는 크기가 모두 같음
- 파일의 생성, 제거, 레코드 삽입과 삭제, 선택 스캔 연산 지원

<Br/>

### 인덱스 
- 대부분의 자료 구조에선 저장된 데이터의 rid를 직접 알 수 없음
- 정렬되지 않은 자료 구조에서 동등 검색을 수행할 경우, 전체 자료 구조를 스캔해야 함
- 인덱스
    - 검색 속도를 올리는 보조 자료 도구

<br/>

### ISAM
- 색인 순차 접근 방식 파일
- 데이터를 순서대로 저장하거나 특정 항목을 색인으로 처리할 수 있는 파일 처리 기법
- 인덱스를 순차적으로 구성하여 큰 인덱스의 성능 문제 해결
    - 인덱스 파일이 클 경우, 인덱스를 계층화 하여 인덱스에 대한 인덱스를 생성
    - 완전한 정적 구조, 인덱스 계층의 페이지가 수정되지 않음
- 파일 구조
    - 인덱스 구역 (비 단말 페이지) 
        - 기본 구역에 있는 레코드들의 위치를 찾아가는 인덱스가 기록되는 구역
    - 기본 구역 (기본 단말 페이지)
        - 실제 레코드들을 기록하는 부분으로, 각 레코드는 키 값 순으로 저장
    - 오버플로우 구역 (오버 플로우 페이지)
        - 기본 구역에 빈 공간이 없을 경우 새 레코드의 삽입을 위한 예비적 구역

<img width="577" alt="image" src="https://user-images.githubusercontent.com/87689191/201507474-a610e1e7-a789-446a-8c3f-e7e9d7626f34.png">

- 데이터가 많으면 성능이 안 좋아질 수 있음
- 데이터가 많으면 그냥 스캔이 더 빠름

<Br/>

### B+트리
- ISAM의 오버 플로의 단접을 개선한 동적 트리 자료구조
- 내부 노드들이 탐색 경로를 유도하고 단말 노드들이 데이터 엔트리를 가지는 균형 트리
    - 트리에서 삽입, 삭제를 수행해도 트리의 균형이 유지
    - 레코드를 탐색할 때 루트로부터 알맞은 단말까지만 가면 됨
- 일반적으로 ISAM보다 좋은 구조

<img width="440" alt="image" src="https://user-images.githubusercontent.com/87689191/201507584-1b99682e-b452-4139-a042-87d521aa0a86.png">

<br/>

### 시스템 카탈로그
- 데이터베이스는 자신이 가지고 있는 모든 데이터에 대한 설명 정보를 저장함
- 관계형 데이터베이스 관리 시스템은 모든 릴레이션과 인덱스에 대해 정보를 유지 관리
- 시스템 카탈로그, 데이터 사전, 마스터 데이터베이스, 메타데이터라 불림
- 저장하는 정보들
    - 릴레이션
        - 릴레이션 이름, 파일 이름, 파일 구조
        - 각 어트리뷰트의 이름과 타입
        - 릴레이션과 관련된 인덱스 이름
        - 무결성 제약 조건
    - 인덱스
        - 인덱스 이름, 인덱스 구조
        - 탐색 키 어트리뷰트
    - 뷰
        - 뷰 이름과 정의
    - 통계
        - 릴레이션 카디널리티
        - 탐색 키가 취할 수 있는 서로 다른 값의 수
        - 인덱스의 최소값과 최대값
    - 그 외
        - 계정 정보
        - 접근 권한

<br/>






